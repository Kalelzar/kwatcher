This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.*undo-tree*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
cache.zig
file_cache.zig
hotcold.zig
memory_cache.zig
set_builder.zig
tiered_cache.zig
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cache.zig">
const std = @import("std");
const Injector = @import("../utils/injector.zig").Injector;
const metrics = @import("../utils/metrics.zig");

pub const SetBuilder = @import("set_builder.zig").SetBuilder;
pub const HotCold = @import("hotcold.zig").HotCold;
pub const Memory = @import("memory_cache.zig").Memory;
pub const MemoryContext = @import("memory_cache.zig").MemoryContext;
pub const File = @import("file_cache.zig").File;
pub const FileContext = @import("file_cache.zig").FileContext;
pub const Tiered = @import("tiered_cache.zig").TieredCache;

pub fn Cache(comptime Data: type) type {
    return struct {
        config: HotCold(Data),
        inj: *Injector,

        pub fn get(self: @This(), invariant: anytype) !Data {
            const arg: *anyopaque = @constCast(&invariant);
            if (self.config.hot) |h| {
                @branchHint(.likely);
                return @call(.auto, h, .{ self.inj, arg });
            } else if (self.config.cold) |c| {
                @branchHint(.unlikely);
                return @call(.auto, c, .{ self.inj, arg });
            } else {
                @branchHint(.cold);
                return error.NullCacheCalled;
            }
        }
    };
}

pub fn autoCacheWithContexts(
    comptime Data: type,
    comptime Invariant: anytype,
    comptime Context: anytype,
) *const fn (*Injector, *anyopaque) anyerror!Data {
    const H = struct {
        pub fn get(inj: *Injector, invariant: *anyopaque) anyerror!Data {
            var hasher = std.crypto.hash.Blake3.init(.{ .key = null });
            const in: *std.meta.Tuple(&Invariant) = @ptrCast(@alignCast(invariant));
            std.hash.autoHashStrat(&hasher, in.*, .DeepRecursive);
            var hashBytes: [32]u8 = undefined;
            hasher.final(&hashBytes);
            const hash = std.fmt.bytesToHex(&hashBytes, .upper);

            const config = try inj.require(HotCold(Data));
            // FIXME: Do ot reguire the contexts twice.
            inline for (0..Context.len) |i| {
                var context = try inj.require(*(Context[i]));
                if (try context.get(&hash)) |r| {
                    try metrics.cacheHit(config.key, Context[i].id);
                    inline for (0..i) |j| {
                        var other_context = try inj.require(*(Context[j]));
                        try other_context.put(&hash, try Data.dupe(other_context.allocator, &r));
                        try metrics.cacheGrow(config.key, Context[j].id);
                    }
                    return r;
                }
                try metrics.cacheMiss(config.key, Context[i].id);
            }

            if (config.cold) |c| {
                const data = try @call(.auto, c, .{ inj, invariant });
                inline for (0..Context.len) |i| {
                    var context = try inj.require(*(Context[i]));
                    try context.put(&hash, data);
                    try metrics.cacheGrow(config.key, Context[i].id);
                }

                return data;
            } else {
                return error.CacheMiss;
            }
        }
    };

    return &H.get;
}
</file>

<file path="file_cache.zig">
const std = @import("std");
const cache = @import("cache.zig");

/// A simple filesystem backed cache.
/// NOTE: This should be converted to a vtable so that the implementation can be swapped by the user.
pub fn FileContext(comptime Data: type) type {
    return struct {
        pub const id = "file";
        dir: std.fs.Dir,
        allocator: std.mem.Allocator,

        pub fn get(self: *@This(), key: []const u8) !?Data {
            const pre = key[0..2];
            const post = key[2..4];
            const rest = key[4..];
            var buf: [8]u8 = undefined;
            const path = try std.fmt.bufPrint(&buf, "{s}/{s}/", .{ pre, post });
            var low = try self.dir.makeOpenPath(path, .{});
            defer low.close();
            var file = low.openFile(rest, .{ .mode = .read_only }) catch |e| switch (e) {
                error.FileNotFound => return null,
                else => return e,
            };
            defer file.close();
            var rbuf: [@sizeOf(Data)]u8 = undefined;
            var r = file.reader(&rbuf);
            const reader = &r.interface;
            return try Data.read(reader, self.allocator);
        }

        pub fn put(self: *@This(), key: []const u8, data: Data) !void {
            const pre = key[0..2];
            const post = key[2..4];
            const rest = key[4..];
            var buf: [8]u8 = undefined;
            const path = try std.fmt.bufPrint(&buf, "{s}/{s}/", .{ pre, post });
            var low = try self.dir.makeOpenPath(path, .{});
            defer low.close();
            var file = try low.createFile(rest, .{});
            defer file.close();
            var wbuf: [@sizeOf(Data)]u8 = undefined;
            var w = file.writer(&wbuf);
            const writer = &w.interface;
            try data.write(writer);
            try writer.flush();
        }

        pub fn init(allocator: std.mem.Allocator, path: []const u8) !@This() {
            return .{
                .dir = try std.fs.cwd().makeOpenPath(path, .{}),
                .allocator = allocator,
            };
        }

        pub fn deinit(self: *@This()) void {
            self.dir.close();
        }
    };
}

pub fn File(comptime Data: type, comptime Invariant: anytype) cache.SetBuilder(Data, Invariant) {
    return cache.SetBuilder(Data, Invariant)
        .new()
        .hotRaw(cache.autoCacheWithContexts(Data, Invariant, .{FileContext(Data)}));
}
</file>

<file path="hotcold.zig">
const Injector = @import("../utils/injector.zig").Injector;

/// A hot/cold cache that will either retrieve from cache or retrieve the element from the cold path
/// and automatically cache it.
pub fn HotCold(comptime Data: type) type {
    return struct {
        key: []const u8,
        hot: ?*const fn (*Injector, *anyopaque) anyerror!Data = null,
        cold: ?*const fn (*Injector, *anyopaque) anyerror!Data = null,
    };
}
</file>

<file path="memory_cache.zig">
const std = @import("std");
const cache = @import("cache.zig");

pub fn Memory(comptime Data: type, comptime Invariant: anytype) cache.SetBuilder(Data, Invariant) {
    return cache.SetBuilder(Data, Invariant)
        .new()
        .hotRaw(cache.autoCacheWithContexts(Data, Invariant, .{MemoryContext(Data)}));
}

/// A simple hash map backed in-memory cache.
/// NOTE: This should be converted to a vtable so that the implementation can be swapped by the user.
pub fn MemoryContext(comptime Data: type) type {
    return struct {
        pub const id = "memory";
        buf: std.StringArrayHashMapUnmanaged(Data),
        allocator: std.mem.Allocator,

        pub fn get(self: *@This(), key: []const u8) !?Data {
            return self.buf.get(key);
        }

        pub fn put(self: *@This(), key: []const u8, data: Data) !void {
            return self.buf.put(
                self.allocator,
                try self.allocator.dupe(u8, key),
                data,
            );
        }

        pub fn init(allocator: std.mem.Allocator) @This() {
            return .{
                .buf = .{},
                .allocator = allocator,
            };
        }

        pub fn deinit(self: *@This()) void {
            var it = self.buf.iterator();
            while (it.next()) |e| {
                self.allocator.free(e.key_ptr.*);
                if (comptime @hasDecl(Data, "deinit")) {
                    // FIXME: Call this function with an allocator if possible.
                    //e.value_ptr.deinit();
                }
            }

            self.buf.deinit(self.allocator);
        }
    };
}
</file>

<file path="set_builder.zig">
const std = @import("std");
const Injector = @import("../utils/injector.zig").Injector;
const cache = @import("cache.zig");

pub fn SetOptions(comptime Data: type) type {
    return union(enum) {
        key: []const u8,
        hot: *const fn (*Injector, *anyopaque) anyerror!Data,
        cold: *const fn (*Injector, *anyopaque) anyerror!Data,
    };
}

pub fn SetBuilder(comptime Data: type, comptime Invariant: anytype) type {
    const Opts = SetOptions(Data);
    return struct {
        opts: []Opts,
        const Self = @This();

        fn extend(comptime self: Self, comptime other: Opts) Self {
            comptime {
                var opts: [self.opts.len + 1]Opts = undefined;
                for (self.opts, 0..) |o, i| {
                    opts[i] = o;
                }
                opts[self.opts.len] = other;
                return .{
                    .opts = &opts,
                };
            }
        }

        pub fn new() Self {
            return comptime .{
                .opts = &.{},
            };
        }

        pub fn key(comptime self: Self, comptime k: anytype) Self {
            return self.extend(.{ .key = @tagName(k) });
        }

        fn handler(comptime f: anytype) *const fn (*Injector, *anyopaque) anyerror!Data {
            const H = struct {
                pub fn handle(
                    inj: *Injector,
                    invariant: *anyopaque,
                ) anyerror!Data {
                    const in: *std.meta.Tuple(&Invariant) = @ptrCast(@alignCast(@constCast(invariant)));

                    return inj.call_first(f, in.*);
                }
            };

            return &H.handle;
        }

        pub fn hot(comptime self: Self, comptime f: anytype) Self {
            return self.extend(.{ .hot = handler(f) });
        }

        pub fn hotRaw(comptime self: Self, comptime f: anytype) Self {
            return self.extend(.{ .hot = f });
        }

        pub fn cold(comptime self: Self, comptime f: anytype) Self {
            return self.extend(.{ .cold = handler(f) });
        }

        fn TypeFor(comptime self: Self) type {
            var has_cold = false;
            var has_hot = false;
            var has_key = false;

            comptime {
                for (self.opts) |opts| {
                    switch (opts) {
                        .key => has_key = true,
                        .cold => has_cold = true,
                        .hot => has_hot = true,
                    }
                }

                if (!has_key) {
                    @compileError("A cache always needs a key!");
                }

                return cache.HotCold(Data);
            }
        }

        pub fn build(comptime self: Self) TypeFor(self) {
            var cache_config = std.mem.zeroInit(TypeFor(self), .{});
            inline for (self.opts) |o| {
                @field(cache_config, @tagName(std.meta.activeTag(o))) = @field(o, @tagName(std.meta.activeTag(o)));
            }
            return cache_config;
        }
    };
}
</file>

<file path="tiered_cache.zig">
const cache = @import("cache.zig");

pub fn TieredCache(comptime Data: type, comptime Invariant: anytype, comptime Tiers: anytype) cache.SetBuilder(Data, Invariant) {
    return cache.SetBuilder(Data, Invariant)
        .new()
        .hotRaw(cache.autoCacheWithContexts(Data, Invariant, Tiers));
}
</file>

</files>
